# üìå Instru√ß√µes para o Agente (Trae)

Voc√™ √© um **engenheiro principal de plataforma** encarregado de gerar um **servidor de API FastAPI** totalmente funcional para **download de v√≠deos** (YouTube, Instagram, Facebook e TikTok) e **transcri√ß√£o de √°udio/v√≠deo**, com **armazenamento no MinIO**. Entregue **c√≥digo de produ√ß√£o** com testes, documenta√ß√£o e `Dockerfile`/`docker-compose`.

> Regras de ouro:
>
> 1. Gere **arquivos completos** (sem trechos omitidos) prontos para rodar.
> 2. Use **yt-dlp** para todos os downloads (cobre YT/IG/FB/TikTok).
> 3. Salve **v√≠deos e transcri√ß√µes** no **MinIO** (com URLs pr√©-assinadas).
> 4. Forne√ßa **rotas s√≠ncronas e ass√≠ncronas** (com fila leve via `BackgroundTasks` do FastAPI).
> 5. Entregue **OpenAPI** completo, tipagem Pydantic, logging estruturado, tratamento de erros e testes.

---

## üéØ Objetivos

* Baixar v√≠deos/√°udios das plataformas suportadas usando `yt-dlp`.
* Persistir artefatos (v√≠deo/√°udio/legendas e transcri√ß√µes em JSON/SRT/VTT) no MinIO.
* Disponibilizar rotas REST para **download**, **status**, **listagem**, **transcri√ß√£o** e **obten√ß√£o de URLs pr√©-assinadas**.
* Executar **transcri√ß√£o** local via **faster-whisper** (FFmpeg obrigat√≥rio).
* Containerizar a aplica√ß√£o (Docker) e facilitar o run com `docker-compose`.

---

## üß± Stack T√©cnica

* **Linguagem:** Python 3.11+
* **Web:** FastAPI + Uvicorn
* **Downloads:** yt-dlp (suporte YT/IG/FB/TikTok)
* **Storage:** MinIO (SDK oficial `minio`)
* **Transcri√ß√£o:** `faster-whisper` (modelos configur√°veis), `ffmpeg`
* **Schemas/Valida√ß√£o:** Pydantic v2
* **Auth:** API Key em header `X-API-Key`
* **Utilit√°rios:** `tenacity` (retries), `python-multipart`, `aiofiles`, `httpx`
* **Testes:** pytest + httpx AsyncClient
* **Observabilidade:** logging JSON + middleware de correla√ß√£o (X-Request-Id)

---

## üîê Vari√°veis de Ambiente (.env exemplo)

```
API_TITLE=Media Downloader API
API_VERSION=1.0.0
API_DEBUG=false
API_KEY=supersecreta

MINIO_ENDPOINT=minio:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_BUCKET=media
MINIO_SECURE=false

# pasta tempor√°ria dentro do container
WORKDIR=/app/data

# Transcri√ß√£o
WHISPER_MODEL=medium
WHISPER_COMPUTE_TYPE=auto  # auto / float16 / int8
WHISPER_LANGUAGE=pt
```

---

## üìÅ Estrutura de Pastas esperada

```
.
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes_downloads.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes_transcriptions.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes_health.py
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ storage.py
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ downloader.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transcription.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.py
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îÇ       ‚îú‚îÄ‚îÄ dto.py
‚îÇ       ‚îî‚îÄ‚îÄ types.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_health.py
‚îÇ   ‚îú‚îÄ‚îÄ test_download_flow.py
‚îÇ   ‚îî‚îÄ‚îÄ test_transcription_flow.py
‚îú‚îÄ‚îÄ pyproject.toml (ou requirements.txt)
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ README.md
```

---

## üßæ Depend√™ncias

Se usar `pyproject.toml`:

```toml
[project]
name = "media-downloader-api"
version = "1.0.0"
requires-python = ">=3.11"
dependencies = [
  "fastapi>=0.111.0",
  "uvicorn[standard]>=0.30.0",
  "yt-dlp>=2024.08.06",
  "minio>=7.2.12",
  "pydantic>=2.7.0",
  "python-multipart>=0.0.9",
  "aiofiles>=23.2.1",
  "httpx>=0.27.0",
  "tenacity>=8.2.3",
  "faster-whisper>=1.0.0"
]
[tool.uvicorn]
reload = true
```

> **Nota:** Garanta `ffmpeg` instalado no container.

---

## ‚òÅÔ∏è Integra√ß√£o com MinIO

* Criar bucket `MINIO_BUCKET` se n√£o existir.
* Upload com `put_object` e `content_type` correto (ex.: `video/mp4`, `application/json`, `text/vtt`, `application/x-subrip`).
* Gerar URLs pr√©-assinadas (`presigned_get_object`) com expira√ß√£o configur√°vel (padr√£o 24h).
* Armazenar com chaves padronizadas: `videos/{id}/{basename}.{ext}`, `transcriptions/{id}/{basename}.json|srt|vtt`.

---

## üß† Transcri√ß√£o (faster-whisper)

* Carregar modelo definido em `WHISPER_MODEL` e `WHISPER_COMPUTE_TYPE`.
* Permitir idioma (`language`) opcional no payload. Default de `.env`.
* Retornar **texto completo** e timestamps por segmento. Persistir **JSON (rico)** + **SRT** + **VTT** no MinIO.

---

## üîÄ Fluxos Principais

1. **Download**:

   * Entrada: `url` (obrigat√≥ria), `format` (ex.: `mp4`), `audio_only` (bool), `quality` (ex.: `best`), `extract_audio` (bool).
   * Sa√≠da: `video_id`, metadados (t√≠tulo, dura√ß√£o), chaves no MinIO e **URL pr√©-assinada**.

2. **Transcrever**:

   * Entrada: `video_id` **ou** `url` (se n√£o baixado ainda). Se `url`, efetuar download tempor√°rio, transcrever e descartar se n√£o for persistir v√≠deo.
   * Sa√≠da: `transcription_id` (pode ser o `video_id`), URLs pr√©-assinadas para JSON/SRT/VTT.

3. **Status**:

   * Retornar status de tarefas disparadas com `BackgroundTasks` (download/transcri√ß√£o), com progresso b√°sico.

---

## üîó Endpoints REST (especifica√ß√£o)

* `GET /health` ‚Üí status da API e do MinIO.
* `POST /downloads` ‚Üí inicia download. **Body**:

```json
{
  "url": "https://...",
  "format": "mp4",
  "quality": "best",
  "audio_only": false,
  "extract_audio": false
}
```

**Resposta 201**:

```json
{
  "video_id": "abc123",
  "title": "...",
  "duration": 123.4,
  "bucket": "media",
  "object_key": "videos/abc123/file.mp4",
  "presigned_url": "https://..."
}
```

* `GET /downloads/{video_id}` ‚Üí obt√©m metadados e URL pr√©-assinada.
* `POST /transcriptions` ‚Üí cria transcri√ß√£o. **Body**:

```json
{
  "video_id": "abc123",
  "language": "pt",
  "model": "medium"
}
```

**Resposta 201**:

```json
{
  "transcription_id": "abc123",
  "json_url": "https://...",
  "srt_url": "https://...",
  "vtt_url": "https://...",
  "language": "pt"
}
```

* `GET /transcriptions/{transcription_id}` ‚Üí detalhes + URLs pr√©-assinadas.
* `GET /status/{task_id}` ‚Üí status da tarefa (download/transcri√ß√£o) se ass√≠ncrona.

> **Auth**: todas as rotas (exceto `/health`) exigem header `X-API-Key` com a chave definida no `.env`.

---

## üß© Requisitos de Implementa√ß√£o

* **Detec√ß√£o de plataforma autom√°tica** via `yt-dlp` (n√£o exigir `platform` no payload).
* **Sanitiza√ß√£o de filename** e limpeza de tempor√°rios em caso de erro.
* **Erros estruturados** (HTTPException com `code`, `message`, `details`).
* **Logging**: JSON, incluir `request_id`, `path`, `elapsed_ms` e `status_code` em middleware.
* **CORS**: permitir origem configur√°vel (ex.: `*` por padr√£o, mas vari√°vel de ambiente para restringir).
* **Retries** (ex.: rede/MinIO) com `tenacity` onde fizer sentido.
* **Valida√ß√£o**: Pydantic com exemplos no schema.
* **OpenAPI**: descri√ß√µes claras e exemplos em cada rota; incluir `/docs` e `/redoc`.

---

## üß™ Testes (pytest)

* **Health**: 200 + checagem de acesso ao bucket.
* **Download Flow**: POST `/downloads` ‚Üí 201 ‚Üí GET por `video_id` ‚Üí 200. Mock de MinIO e yt-dlp em testes.
* **Transcription Flow**: POST `/transcriptions` (com `video_id` preparado) ‚Üí 201, e valida√ß√£o de URLs.

---

## üê≥ Docker & Compose

**Dockerfile** (requisito):

* Base `python:3.11-slim`.
* Instalar `ffmpeg` e depend√™ncias do `faster-whisper` (ex.: `ffmpeg`, `build-essential`, `git`).
* Copiar projeto, instalar deps (usar `uv`/`pip`), criar usu√°rio n√£o-root.
* CMD: `uvicorn app.main:app --host 0.0.0.0 --port 8000`.

**docker-compose.yml** (requisito):

* Servi√ßo `api` + servi√ßo `minio` + `minio-console`.
* Volumes persistentes para MinIO e `/app/data`.
* Rede compartilhada; healthchecks.

---

## ‚úÖ Crit√©rios de Aceite

* Subir com `docker compose up` e `/health` retornar OK.
* `POST /downloads` baixar e disponibilizar URL pr√©-assinada no MinIO.
* `POST /transcriptions` gerar JSON/SRT/VTT e disponibilizar URLs.
* Documenta√ß√£o de uso no `README.md` (passo a passo, exemplos curl e `HTTPie`).

---

## ‚úçÔ∏è Entreg√°veis

1. C√≥digo completo (estrutura acima) com **docstrings** e coment√°rios.
2. `Dockerfile`, `docker-compose.yml`, `.env.example` e `README.md`.
3. Testes `pytest` cobrindo fluxos principais.

---

## üß≠ Passo a Passo que voc√™ (Trae) deve seguir

1. **Gerar projeto** com a estrutura descrita e arquivos completos.
2. **Implementar** `config`, `security` (API Key), `storage` (MinIO), `downloader` (yt-dlp), `transcription` (faster-whisper), rotas, modelos Pydantic e middleware de logging/correla√ß√£o.
3. **Criar** `Dockerfile` e `docker-compose.yml` com servi√ßos `api`, `minio`, `minio-console`.
4. **Adicionar** testes `pytest`.
5. **Gerar** `README.md` com instru√ß√µes:

   * `cp .env.example .env`
   * `docker compose up -d`
   * Exemplos `curl`/`httpie` para cada rota.
6. **Validar** localmente (simula√ß√£o), garantindo que os exemplos do README funcionem.

---

## üîß Exemplos de uso (para README)

**Download:**

```bash
http POST :8000/downloads \
  X-API-Key:supersecreta \
  url=https://www.youtube.com/watch?v=dQw4w9WgXcQ \
  format=mp4 quality=best audio_only:=false extract_audio:=false
```

**Transcri√ß√£o:**

```bash
http POST :8000/transcriptions \
  X-API-Key:supersecreta \
  video_id=abc123 language=pt model=medium
```

**Obter URLs:**

```bash
http GET :8000/downloads/abc123 X-API-Key:supersecreta
http GET :8000/transcriptions/abc123 X-API-Key:supersecreta
```

---

## üß± Padr√µes de C√≥digo (resumo)

* Fun√ß√µes curtas, puras quando poss√≠vel.
* Tipagem r√≠gida (`from __future__ import annotations`).
* Separa√ß√£o clara entre **camada de API** (FastAPI/DTOs) e **servi√ßos** (downloader/transcription/storage).
* Mensagens de erro em portugu√™s claro, por√©m chaves/fields em ingl√™s para consist√™ncia de API.

---

## üéÅ B√¥nus (se couber)

* Suporte a **legendas nativas** via `yt-dlp` quando dispon√≠veis.
* Suporte a **download de playlists** (enfileirando itens).
* **Limite de taxa** (rate limit) simples por IP/chave.
* **ETags** e cache-control para recursos est√°ticos via proxy (fora do escopo do FastAPI em si).

---

> **Sa√≠da esperada deste prompt**: um pacote de c√≥digo completo, com todos os arquivos e conte√∫do integral, pronto para `docker compose up` e uso imediato das rotas descritas acima.
